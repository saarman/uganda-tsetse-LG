---
title: "RF model full – LC lakes paths"
author: "Norah Saarman"
date: "2025-06-17"
output:
  github_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
RStudio Configuration:  
- **R version:** R 4.4.0 (Geospatial packages)  
- **Number of cores:** 4 (up to 32 available)   
- **Account:** saarman-np  
- **Partition:** saarman-shared-np (allows multiple simultaneous jobs)  
- **Memory per job:** 100G (cluster limit: 1000G total; avoid exceeding half)    
# Setup
```{r libraries, warning=FALSE, results=FALSE, message=FALSE}
# load only required packages
library(randomForest)
library(doParallel)
library(raster)
library(sf)
library(viridis)
library(dplyr)
library(terra)
library(sf)
library(classInt)
library(raster)
library(RColorBrewer)

# base directories
data_dir  <- "/uufs/chpc.utah.edu/common/home/saarman-group1/uganda-tsetse-LG/data"
input_dir <- "../input"
results_dir <- "/uufs/chpc.utah.edu/common/home/saarman-group1/uganda-tsetse-LG/results"

# read the combined CSE + coords table + pix_dist + Env variables
V.table <- read.csv(file.path(input_dir, "Gff_cse_envCostPaths.csv"),
                    header = TRUE)
# This was added only after completing LOPOCV...
# Filter out western outlier "50-KB" 
V.table <- V.table %>%
  filter(Var1 != "50-KB", Var2 != "50-KB")

# define coordinate reference system
crs_geo <- 4326     # EPSG code for WGS84

# simple mode helper
get_mode <- function(x) {
  ux <- unique(x[!is.na(x)])
  ux[ which.max(tabulate(match(x, ux))) ]
}

# setup running in parallel
cl <- makeCluster(4)
registerDoParallel(cl)
clusterExport(cl, "get_mode")
```

# Inputs  
  - `../input/Gff_cse_envCostPaths.csv`  - Combined CSE table with coordinates (long1, lat1, long2, lat2), pix_dist = geographic distance in sum of pixels, and mean, median, mode of each Env parameter  
# Outputs  
  - `../results_dir/rf_mean_full_tuned.rds`  - Full RF model output, readRDS() to load  
  - `../results_dir/predicted_CSEdistance.tif` - Projection of full RF model, with pix_dist and samp_20km nuetralized by using uniform layers in projection
  
# 1. Prepare the data
```{r prep, warning=FALSE}
# Assign input, checking for any rows with NA
sum(!complete.cases(V.table))  # should return 0
rf_data <- na.omit(V.table)    # should omit zero rows

# Confirm that CSEdistance is numeric
rf_data$CSEdistance <- as.numeric(rf_data$CSEdistance)

# Select variables: all predictors (mean, median, mode)  
predictor_vars <- c("pix_dist",                      # geo dist
  paste0("BIO", 1:7, "_mean"),                       # mean 
  paste0("BIO", 8:11, "S_mean"),                     # mean
  paste0("BIO", 12:15, "_mean"),                     # mean
  paste0("BIO", 16:19, "S_mean"),                    # mean
  "alt_mean", "slope_mean", "riv_3km_mean",          # mean
  "samp_20km_mean", "lakes_mean",                    # mean
  paste0("BIO", 1:7, "_median"),                     # median
  paste0("BIO", 8:11, "S_median"),                   # median
  paste0("BIO", 12:15, "_median"),                   # median
  paste0("BIO", 16:19, "S_median"),                  # median
  "alt_median", "slope_median", "riv_3km_median",    # median
  "samp_20km_median", "lakes_median",                # median
  paste0("BIO", 1:7, "_mode"),                       # mode
  paste0("BIO", 8:11, "S_mode"),                     # mode
  paste0("BIO", 12:15, "_mode"),                     # mode
  paste0("BIO", 16:19, "S_mode"),                    # mode
  "alt_mode", "slope_mode", "riv_3km_mode",          # mode
  "samp_20km_mode", "lakes_mode"                     # mode
)

# subset predictors that we want to use
rf_data <- rf_data[, c("CSEdistance", predictor_vars)]
```

# 2. Build full Random Forest model 
```{r rf-full, warning=FALSE}
# Build full RF model
set.seed(1234)  # ensures reproducibility
rf_full <- randomForest(
  CSEdistance ~ .,
  data = rf_data,
  importance = TRUE,
  ntree = 500
)

print(rf_full)

importance(rf_full)
```

# 2. Prune variables?

## Compare mean versus median versus mode:
```{r mean-v-median-v-mode, warning=FALSE}
# Extract groups of variables by suffix
mean_vars   <- grep("_mean$", names(rf_data), value = TRUE)
median_vars <- grep("_median$", names(rf_data), value = TRUE)
mode_vars   <- grep("_mode$", names(rf_data), value = TRUE)

# Always include geographic distance
common_var <- "pix_dist"

# Build and run each model
set.seed(123438972)  # ensures reproducibility
rf_mean <- randomForest(CSEdistance ~ ., data = rf_data[, c("CSEdistance", common_var, mean_vars)], ntree = 500, importance = TRUE)
rf_median <- randomForest(CSEdistance ~ ., data = rf_data[, c("CSEdistance", common_var, median_vars)], ntree = 500, importance = TRUE)
rf_mode <- randomForest(CSEdistance ~ ., data = rf_data[, c("CSEdistance", common_var, mode_vars)], ntree = 500, importance = TRUE)

# Compare performance
c(mean = rf_mean$rsq[500] * 100,
  median = rf_median$rsq[500] * 100,
  mode = rf_mode$rsq[500] * 100)
```

Including mean of env variable along least cost paths performs the best, adding median and mode does not greatly improve the model and increases risks of over fitting...

## (Optional) Prune more variables after narrowing to mean only?

```{r prune-mean, warning=FALSE, eval=FALSE}
# Plot variable importance
par(mar = c(5, 10, 2, 2))  # bottom, left, top, right
varImpPlot(rf_mean, main = "Mean Model Importance",cex = 0.6, pch = 19)

# Rank variables by %IncMSE (from tuned model)
imp <- importance(rf_mean)[, "%IncMSE"]
imp <- sort(imp, decreasing = TRUE)

# Multiple runs with N top predictors
# Store results
prune_results <- list()
n_list <- c(5:length(imp))

for (n in n_list) {
  top_vars <- names(imp)[1:n]
  formula_n <- as.formula(paste("CSEdistance ~", paste(top_vars, collapse = " + ")))
  
  set.seed(1234783645)
  rf_n <- randomForest(
    formula = formula_n,
    data = rf_data,
    ntree = 500,
    importance = TRUE
  )
  
  prune_results[[paste0("Top", n)]] <- rf_n
}

sapply(prune_results, function(mod) {
  c(OOB_MSE = mod$mse[500], VarExpl = mod$rsq[500] * 100)
})
```
% Variance Explained increases rapidly up to around 18 variables, after which it plateaus.

OOB MSE decreases quickly early on, with minimal gains beyond the top ~18 predictors.

However, there are not too many more than 18 total, and many of the env variables have similar node purity, so I will leave all mean variables in.

# 3. Final full model - (Tune random forest with mean variables)
```{r tune, warning=FALSE}
# Load data
V.table_full <- read.csv(file.path(input_dir, "Gff_cse_envCostPaths.csv"))

# estimate mean sampling density
mean(V.table_full$samp_20km_mean, na.rm = TRUE)

# Filter out western outlier "50-KB" 
V.table <- V.table_full %>%
  filter(Var1 != "50-KB", Var2 != "50-KB")

# Filter for within-cluster pairs AND geographic distance ≤ 100 km
#V.table <- V.table_full %>%
#  filter(Pop1_cluster == Pop2_cluster) %>%
#  filter(pix_dist <= 100)

# Create unique ID after filtering
V.table$id <- paste(V.table$Var1, V.table$Var2, sep = "_")

# Define site list
sites <- sort(unique(c(V.table$Var1, V.table$Var2)))

# How many rows of data for each?
table(V.table$Pop1_cluster)

# How many unique sites?
length(sites)

# Choose predictors for RF model (adjust names if necessary)
predictor_vars <- c("BIO1_mean","BIO2_mean","BIO3_mean","BIO4_mean", "BIO5_mean","BIO6_mean","BIO7_mean", "BIO8S_mean", "BIO9S_mean","BIO10S_mean", "BIO11S_mean","BIO12_mean", "BIO13_mean","BIO14_mean","BIO15_mean","BIO16S_mean","BIO17S_mean", "BIO18S_mean","BIO19S_mean","slope_mean","alt_mean", "lakes_mean","riv_3km_mean", "samp_20km_mean","pix_dist")

# Filter to modeling-relevant columns only
rf_mean_data <- V.table[, c("CSEdistance", predictor_vars)]

# Rename predictors by removing "_mean" for later projections
names(rf_mean_data) <- gsub("_mean$", "", names(rf_mean_data))

# Tune mtry (number of variables tried at each split)
set.seed(92834567)
rf_mean_full_tuned <- tuneRF(
  x = rf_mean_data[, -1],   # exclude response variable
  y = rf_mean_data$CSEdistance,
  ntreeTry = 500,
  stepFactor = 1.5,         # factor by which mtry is increased/decreased
  improve = 0.01,           # minimum improvement to continue search
  trace = TRUE,             # print progress
  plot = TRUE,              # plot OOB error vs mtry
  doBest = TRUE,             # return the model with lowest OOB error
  importance = TRUE
)


# Save the tuned random forest model to disk
saveRDS(rf_mean_full_tuned, file = file.path(results_dir, "rf_mean_full_tuned.rds"))

# Preserve as-is for projection
rf_final <- rf_mean_full_tuned
```
FYI: Later, to load the model back into R:
`rf_mean_full_tuned <- readRDS(file.path(results_dir, "rf_mean_full_tuned.rds"))`

## (Optional) Compare full and full tuned models (mean-only predictors)
```{r compare, eval=FALSE,warning=FALSE}

# Build full RF model
set.seed(10981234)  # ensures reproducibility
rf_mean_full <- randomForest(
  CSEdistance ~ .,
  data = rf_mean_data,
  importance = TRUE,
  ntree = 500
)

print(rf_mean_full)
importance(rf_mean_full)

print(rf_mean_full_tuned)
importance(rf_mean_full_tuned)

data.frame(
  Model = c("Full (default mtry)", paste("Tuned (mtry = ",rf_mean_full_tuned$mtry,")")),
  MSE = c(rf_mean_full$mse[rf_mean_full$ntree], rf_mean_full_tuned$mse[rf_mean_full_tuned$ntree]),
  Rsq = c(rf_mean_full$rsq[rf_mean_full$ntree], rf_mean_full_tuned$rsq[rf_mean_full_tuned$ntree])
)

# pad names to trick varImpPlot
rownames(rf_mean_full$importance) <- paste0("  ", rownames(rf_mean_full$importance), "  ")
rownames(rf_mean_full_tuned$importance) <- paste0("  ", rownames(rf_mean_full_tuned$importance), "  ")

# plot with varImpPlot
par(mar = c(5, 30, 2,2))  # bottom, left, top, right
varImpPlot(rf_mean_full, main = "Full Model Importance",cex = 0.6, pch = 19)
varImpPlot(rf_mean_full_tuned, main = "Tuned Full Model Importance",cex = 0.6, pch = 19)
```

The tuned model performs slightly better, but the gain may not be meaningful... however, it does confirm that the model is stable and that the mean-only predictors carry strong signal.

Top 18 mean-based predictors retain nearly all the explanatory power of the original full model with 42 predictors.

# 4. Map of projected model

## Build Projection
```{r projection, warning=FALSE}
# Load env stack with named layers
env <- stack(file.path(data_dir, "processed", "env_stack.grd"))
env$samp_20km <- 1.027064e-11 #neutralize sampling bias

# Load rdf of final model
rf_final <- readRDS(file.path(results_dir, "rf_mean_full_tuned.rds"))
prediction_raster <- predict(env, rf_final, type = "response")

# Write Prediction Raster to file
#writeRaster(prediction_raster, file.path(results_dir,"fullRF_CSE_resistance.tif"), format = "GTiff", overwrite = TRUE)
```
  
## Plot predicted CSE
```{r plot-projection, warning=FALSE}
# Create base plot with viridis
plot(prediction_raster,
     col = viridis::magma(100),
     main = "Predicted CSE Distance",
     axes = FALSE,
     box = FALSE,
     #zlim = c(.15,.45),  # CSE limits
     legend.args = list(text = "Predicted CSE", side = 3, line = 1, cex = 1))

# Overlay lakes in dark gray
lakes <- st_read(file.path(data_dir, "raw/ne_10m_lakes.shp"), quiet = TRUE)
lakes <- st_transform(lakes, crs = st_crs(prediction_raster))  # match CRS 
lakes <- st_make_valid(lakes) # fix geometries
r_ext <- st_as_sfc(st_bbox(prediction_raster)) # extent
st_crs(r_ext) <- st_crs(prediction_raster) # match CRS
lakes <- st_intersection(lakes, r_ext) # clip to extent
plot(st_geometry(lakes), col = "gray20", border = NA, add = TRUE)

# Overlay country outline
uganda <- rnaturalearth::ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
uganda <- st_intersection(uganda, r_ext) # clip to extent
plot(st_geometry(uganda), col = NA, border = "black", lwd = 1.2, add = TRUE)
```

## (Optional) Scale CSE 
```{r scaled-CSE, eval = FALSE, warning=FALSE}
# Explored scaled-CSE, but performance was minimally improved
# Load data
V.table_full <- read.csv(file.path(input_dir, "Gff_cse_envCostPaths.csv"))

# estimate mean sampling density
uniform_samp <- mean(V.table_full$samp_20km_mean, na.rm = TRUE)
message("The mean sampling density is: ", uniform_samp)
  
# Filter out western outlier "50-KB" 
V.table <- V.table_full %>%
  filter(Var1 != "50-KB", Var2 != "50-KB")

# Create unique ID after filtering
V.table$id <- paste(V.table$Var1, V.table$Var2, sep = "_")

# Define top 18 mean predictors (adjust names if necessary)
predictor_vars <- c("pix_dist", "samp_20km_mean", "BIO3_mean", "BIO6_mean", "BIO15_mean","BIO13_mean", "BIO11S_mean", "BIO7_mean", "BIO1_mean", "BIO9S_mean","BIO12_mean", "alt_mean", "BIO18S_mean", "BIO4_mean", "BIO2_mean","slope_mean", "BIO10S_mean", "riv_3km_mean")

max_CSE <- max(V.table$CSEdistance, na.rm = TRUE)
V.table$CSE_scaled <- V.table$CSEdistance / max_CSE

# Filter to modeling-relevant columns only
rf_data <- V.table[, c("CSE_scaled", predictor_vars)]

# Rename predictors by removing "_mean" for later projections
names(rf_data) <- gsub("_mean$", "", names(rf_data))

# Build full RF model
set.seed(10981234)  # ensures reproducibility
rf_scaled <- randomForest(
  CSE_scaled ~ .,
  data = rf_data,
  importance = TRUE,
  ntree = 500
)

print(rf_scaled)
importance(rf_scaled)

# Tune mtry (number of variables tried at each split)
set.seed(92834567)
rf_scaled_tuned <- tuneRF(
  x = rf_data[, -1],   # exclude response variable
  y = rf_data$CSE_scaled,
  ntreeTry = 500,
  stepFactor = 1.5,         # factor by which mtry is increased/decreased
  improve = 0.01,           # minimum improvement to continue search
  trace = TRUE,             # print progress
  plot = TRUE,              # plot OOB error vs mtry
  doBest = TRUE,             # return the model with lowest OOB error
  importance = TRUE
)


# Save the tuned random forest model to disk
saveRDS(rf_scaled_tuned, file = file.path(results_dir, "rf_scaled_tuned.rds"))

# Preserve as-is for projection
rf_final <- rf_scaled_tuned

print(rf_scaled)
print(rf_scaled_tuned)

data.frame(
  Model = c("Full (default mtry)", paste("Tuned (mtry = ",rf_scaled_tuned$mtry,")")),
  MSE = c(rf_scaled$mse[rf_scaled$ntree], rf_scaled_tuned$mse[rf_scaled_tuned$ntree]),
  Rsq = c(rf_scaled$rsq[rf_scaled$ntree], rf_scaled_tuned$rsq[rf_scaled_tuned$ntree])
)

# pad names to trick varImpPlot
rownames(rf_scaled$importance) <- paste0("  ", rownames(rf_scaled$importance), "  ")
rownames(rf_scaled_tuned$importance) <- paste0("  ", rownames(rf_scaled_tuned$importance), "  ")

# plot with varImpPlot
par(mar = c(5, 30, 2,2))  # bottom, left, top, right
varImpPlot(rf_scaled, main = "Full Model Importance",cex = 0.6, pch = 19)
varImpPlot(rf_scaled_tuned, main = "Tuned Full Model Importance",cex = 0.6, pch = 19)

# 4. Projection of model
# Load env stack with named layers
env <- stack(file.path(data_dir, "processed", "env_stack.grd"))

# Replace samp_20km with neutral constant raster, 
# retains sampling bias in the model but neutralize 
# sampling bias during projection
samp_uniform <- env[["samp_20km"]]
values(samp_uniform) <- mean(rf_data$samp_20km, na.rm = TRUE)
env[["samp_20km"]] <- samp_uniform # Replace in raster stack

prediction_raster <- predict(env, rf_final, type = "response")

# Write Prediction Raster to file
#writeRaster(prediction_raster, file.path(results_dir,"fullRF_CSE_scaled_resistance.tif"), format = "GTiff", overwrite = TRUE)

# Create base plot with viridis
plot(prediction_raster,
     col = viridis::magma(100),
     main = "Predicted Scaled CSE",
     axes = FALSE,
     box = FALSE,
     legend.args = list(text = "Scaled CSE", side = 2, line = 2.5, cex = 0.8))

# Overlay lakes in dark gray
lakes <- st_read(file.path(data_dir, "raw/ne_10m_lakes.shp"), quiet = TRUE)
lakes <- st_transform(lakes, crs = st_crs(prediction_raster))  # match CRS 
lakes <- st_make_valid(lakes) # fix geometries
r_ext <- st_as_sfc(st_bbox(prediction_raster)) # extent
st_crs(r_ext) <- st_crs(prediction_raster) # match CRS
lakes <- st_intersection(lakes, r_ext) # clip to extent
plot(st_geometry(lakes), col = "gray20", border = NA, add = TRUE)

# Overlay country outline
uganda <- rnaturalearth::ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
uganda <- st_intersection(uganda, r_ext) # clip to extent
plot(st_geometry(uganda), col = NA, border = "black", lwd = 1.2, add = TRUE)

prediction_raster <- (predict(env, rf_final, type = "response")) * max_CSE

# Write Prediction Raster to file
#writeRaster(prediction_raster, file.path(results_dir,"fullRF_CSE_unscaled_resistance.tif"), format = "GTiff", overwrite = TRUE)

# Create base plot with viridis
plot(prediction_raster,
     col = viridis::magma(100),
     main = "Predicted CSE",
     axes = FALSE,
     box = FALSE,
     legend.args = list(text = "CSE", side = 2, line = 2.5, cex = 0.8))

# Overlay lakes in dark gray
lakes <- st_read(file.path(data_dir, "raw/ne_10m_lakes.shp"), quiet = TRUE)
lakes <- st_transform(lakes, crs = st_crs(prediction_raster))  # match CRS 
lakes <- st_make_valid(lakes) # fix geometries
r_ext <- st_as_sfc(st_bbox(prediction_raster)) # extent
st_crs(r_ext) <- st_crs(prediction_raster) # match CRS
lakes <- st_intersection(lakes, r_ext) # clip to extent
plot(st_geometry(lakes), col = "gray20", border = NA, add = TRUE)

# Overlay country outline
uganda <- rnaturalearth::ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
uganda <- st_intersection(uganda, r_ext) # clip to extent
plot(st_geometry(uganda), col = NA, border = "black", lwd = 1.2, add = TRUE)
```
Performance of the full model did not improve, so no need to scale CSE before modeling.

# 5. Scale CSE and SDM

## Scale 0-1, habitat suitability and inverse of CSE
```{r bivmap-scale, warning=FALSE}

# Load raster layers
con_raster <- rast(file.path(results_dir, "fullRF_CSE_resistance.tif"))
fao <- rast(file.path(data_dir, "FAO_fuscipes_2001.tif"))
update <- rast(file.path(data_dir, "SDM_2018update.tif"))

# Match extent and resolution first
fao_crop <- crop(fao, update)
update_crop <- crop(update, fao_crop)
fao_resamp <- resample(fao_crop, update_crop)  # if needed to match resolution

# Combine
sdm_raw <- max(fao_resamp, update_crop, na.rm = TRUE)

# Crop to overlapping extent
sdm <- crop(sdm_raw, con_raster)
con <- crop(con_raster, sdm)

# Mask low-suitability areas
sdm[sdm <= 0.05] <- NA


# Rescale to 0–1
sdm_min <- global(sdm, "min", na.rm = TRUE)$min
sdm_max <- global(sdm, "max", na.rm = TRUE)$max
sdm <- (sdm - sdm_min) / (sdm_max - sdm_min)

# Mask to common suitable area
con <- mask(con, sdm)

# Rescale inverse of CSE to 0-1
con_min <- global(con, "min", na.rm = TRUE)$min
con_max <- global(con, "max", na.rm = TRUE)$max
con <- 1 - ((con - con_min) / (con_max - con_min))

# Convert back to raster for compatibility with bivariate.map function
sdm_r <- raster(sdm)
con_r <- raster(con)
```
## Plot scaled CSE and SDM

```{r plot-sdm-con, warning=FALSE}
# Plot Genetic Connectivity (inverse CSE)
plot(con,
     col = rev(viridis::plasma(100)),  # high connectivity = dark
     main = "Genetic Connectivity (inverse CSE)",
     axes = FALSE, box = FALSE,
     legend.args = list(text = "Connectivity", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda), border = "black", lwd = 0.25, add = TRUE)

# Plot Habitat Suitability
plot(sdm,
     col = viridis::viridis(100),  # high suitability = dark
     main = "Habitat Suitability",
     axes = FALSE, box = FALSE,
     legend.args = list(text = "Suitability", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda), border = "black", lwd = 0.25, add = TRUE)


# Plot with custom colors

# Custom palettes based on Bishop et al.
connectivity_colors <- colorRampPalette(c("#FFFF00", "#FFA500", "#FF4500", "#700E40", "#2E003E"))(100)
suitability_colors  <- colorRampPalette(c("white", "lightblue", "blue4"))(100)     # white → light blue → dark blue

# Plot Genetic Connectivity (inverse CSE) with custom colors
plot(con,
     col = connectivity_colors,
     main = "Genetic Connectivity (inverse CSE)",
     axes = FALSE, box = FALSE,
     legend.args = list(text = "Connectivity", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda), border = "black", lwd = 0.25, add = TRUE)

# Plot Habitat Suitability with custom colors
plot(sdm,
     col = suitability_colors,
     main = "Habitat Suitability",
     axes = FALSE, box = FALSE,
     legend.args = list(text = "Suitability", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda), border = "black", lwd = .25, add = TRUE)
```

# 6. Bivariate map
## Define and run functions
```{r bivmap-functions, warning=FALSE}
# Define color matrix function
colmat <- function(nquantiles = 10, 
                   upperleft = rgb(0,150,235, maxColorValue=255), 
                   upperright = "#700E40", 
                   bottomleft = "grey", 
                   bottomright = rgb(255,230,15, maxColorValue=255), 
                   xlab = "x label", 
                   ylab = "y label") {
  my.data <- seq(0, 1, .01)
  my.class <- classIntervals(my.data, n = nquantiles, style = "quantile")
  my.pal.1 <- findColours(my.class, c(upperleft, bottomleft))
  my.pal.2 <- findColours(my.class, c(upperright, bottomright))
  col.matrix <- matrix(nrow = 101, ncol = 101, NA)
  for (i in 1:101) {
    my.col <- c(paste(my.pal.1[i]), paste(my.pal.2[i]))
    col.matrix[102 - i, ] <- findColours(my.class, my.col)
  }
  plot(c(1,1), pch = 19, col = my.pal.1, cex = 0.5, xlim = c(0,1), ylim = c(0,1),
       frame.plot = FALSE, xlab = xlab, ylab = ylab, cex.lab = 1.8)
  for (i in 1:101) {
    col.temp <- col.matrix[i - 1, ]
    points(my.data, rep((i - 1)/100, 101), pch = 15, col = col.temp, cex = 1)
  }
  seqs <- seq(0, 100, (100 / nquantiles))
  seqs[1] <- 1
  col.matrix <- col.matrix[c(seqs), c(seqs)]
}

# Define bivmap function
bivariate.map <- function(rasterx, rastery, colormatrix = col.matrix, nquantiles = 10) {
  # Quantiles for raster x
  quanmean <- getValues(rasterx)
  temp <- data.frame(quanmean, quantile = rep(NA, length(quanmean)))
  brks <- with(temp, unique(quantile(quanmean, na.rm = TRUE, probs = seq(0, 1, 1 / nquantiles))))
  r1 <- within(temp, quantile <- cut(quanmean, breaks = brks, labels = 2:length(brks), include.lowest = TRUE))
  quantr <- data.frame(r1[,2]) 

  # Quantiles for raster y
  quanvar <- getValues(rastery)
  temp <- data.frame(quanvar, quantile = rep(NA, length(quanvar)))
  brks <- with(temp, unique(quantile(quanvar, na.rm = TRUE, probs = seq(0, 1, 1 / nquantiles))))
  r2 <- within(temp, quantile <- cut(quanvar, breaks = brks, labels = 2:length(brks), include.lowest = TRUE))
  quantr2 <- data.frame(r2[,2])

  # Color assignment
  as.numeric.factor <- function(x) as.numeric(levels(x))[x]
  col.matrix2 <- colormatrix
  cn <- unique(colormatrix)
  for (i in 1:length(col.matrix2)) {
    col.matrix2[i] <- ifelse(is.na(col.matrix2[i]), 1, which(col.matrix2[i] == cn)[1])
  }

  cols <- numeric(length(quantr[,1]))
  for (i in 1:length(quantr[,1])) {
    a <- as.numeric.factor(quantr[i,1])
    b <- as.numeric.factor(quantr2[i,1])
    cols[i] <- as.numeric(col.matrix2[b, a])
  }

  r <- rasterx
  r[1:length(r)] <- cols
  return(r)
}

# Check how many quantiles are available
length(unique(quantile(getValues(con_r), probs = seq(0, 1, 0.1), na.rm = TRUE)))
length(unique(quantile(getValues(sdm_r), probs = seq(0, 1, 0.1), na.rm = TRUE)))

# Create color matrix
col.matrix <- colmat(nquantiles = 9, xlab = "Genetic Connectivity", ylab = "Habitat Suitability")

# Create bivariate map
bivmap <- bivariate.map(con_r, sdm_r, colormatrix = col.matrix, nquantiles = 9)
bivmap_terra <- rast(bivmap)  # convert from RasterLayer to SpatRaster

# Write raster file
#writeRaster(bivmap, file.path(results_dir, "bivmap_suitability_connectivity.tif"),
           # filetype = "GTiff", overwrite = TRUE)

```
## Plot bivmap
```{r plot-bivmap, warning=FALSE}
# Load shape files with sf
lakes   <- st_read(file.path(data_dir, "raw/ne_10m_lakes.shp"), quiet = TRUE)
uganda  <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf", continent = "Africa")
library(terra)

bivmap_terra <- rast(bivmap)  # convert from RasterLayer to SpatRaster
uganda_cropped <- st_crop(uganda, bivmap_terra)

# Plot
#pdf("../figures/bivmap.pdf", width = 14, height = 10)
plot(bivmap,
     col = as.vector(col.matrix),
     legend = FALSE,
     axes = FALSE,
     box = FALSE,
     main = "Habitat Suitability vs Genetic Connectivity")
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda_cropped), border = "black", lwd = 0.25, add = TRUE)
#dev.off()
```

# 7. Forecast projection 

## Build forecast projection: Predict across raster
```{r predict-on-raster, warning=FALSE}
# Load rdf of final model
rf_final <- readRDS(file.path(results_dir, "rf_mean_full_tuned.rds"))

# Load env stack with named layers
envRCP <- stack(file.path(data_dir, "processed", "env_stack_RCP4_5.grd"))

plot(envRCP[[20:25]])
plot(env[[20:25]])

# make ABSOLUTELY CERTAIN all layers I want to stay the same DO stay the same
#envRCP$alt <- env$alt
#envRCP$slope <- env$slope
#envRCP$riv_3km <- env$riv_3km
#envRCP$samp_20km <- env$samp_20km
#envRCP$lakes <- env$lakes
#envRCP$pix_dist <- env$pix_dist

#neutralize sampling bias
envRCP$samp_20km <- 1.027064e-11 

# predict with model
prediction_RCP4_5 <- predict(envRCP, rf_final, type = "response")
prediction_raster <- predict(env, rf_final, type = "response")
delta <- prediction_RCP4_5 - prediction_raster

plot(stack(prediction_RCP4_5, prediction_raster,delta))

# Write Prediction Raster to file
# writeRaster(prediction_RCP4_5, file.path(results_dir,"fullRF_CSE_resistance_RCP4_5.tif"), format = "GTiff", overwrite = TRUE)
```
## Plot forecast
```{r plot-projection, warning=FALSE}
# Create base plot with viridis
plot(prediction_RCP4_5,
     col = viridis::magma(100),
     main = "Predicted CSE Distance",
     axes = FALSE,
     box = FALSE,
     #zlim = c(.15,.45),  # CSE limits
     legend.args = list(text = "Predicted CSE", side = 3, line = 1, cex = 1))

# Overlay lakes in dark gray
lakes <- st_read(file.path(data_dir, "raw/ne_10m_lakes.shp"), quiet = TRUE)
lakes <- st_transform(lakes, crs = st_crs(prediction_raster))  # match CRS 
lakes <- st_make_valid(lakes) # fix geometries
r_ext <- st_as_sfc(st_bbox(prediction_raster)) # extent
st_crs(r_ext) <- st_crs(prediction_raster) # match CRS
lakes <- st_intersection(lakes, r_ext) # clip to extent
plot(st_geometry(lakes), col = "gray20", border = NA, add = TRUE)

# Overlay country outline
uganda <- rnaturalearth::ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
uganda <- st_intersection(uganda, r_ext) # clip to extent
plot(st_geometry(uganda), col = NA, border = "black", lwd = 1.2, add = TRUE)
```

## Scale forecast
```{r scale-forecast, warning=FALSE}

# Load raster layers
con_raster_forecast <- rast(file.path(results_dir, "fullRF_CSE_resistance_RCP4_5.tif"))

# Crop to overlapping extent
con_forecast<- crop(con_raster_forecast, sdm)

# Mask to common suitable area
con_forecast <- mask(con_forecast,sdm)

# Rescale inverse of CSE to 0-1
forecast_min <- global(con_forecast, "min", na.rm = TRUE)$min
forecast_max <- global(con_forecast, "max", na.rm = TRUE)$max
con_forecast <- 1 - ((con_forecast - forecast_min) / (forecast_max - forecast_min))
```

## Plot scaled forecast of CSE 
```{r plot-scaled-forecast, warning=FALSE}
uganda_cropped <- st_crop(uganda, con_forecast)

# Plot Forecast of Genetic Connectivity (inverse CSE)
plot(con_forecast,
     col = rev(viridis::plasma(100)),  # high connectivity = dark
     main = "Genetic Connectivity (inverse CSE)",
     axes = FALSE, box = FALSE,
     legend.args = list(text = "Connectivity", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda_cropped), border = "black", lwd = 0.25, add = TRUE)
```
# 8. Compare surfaces 

## Env conditions
```{r compare-env, warning=FALSE}

# Create the difference layers
diff_list <- list(
  envRCP$BIO1 - env$BIO1,
  envRCP$BIO2 - env$BIO2,
  envRCP$BIO3 - env$BIO3,
  envRCP$BIO4 - env$BIO4,
  envRCP$BIO5 - env$BIO5,
  envRCP$BIO6 - env$BIO6,
  envRCP$BIO7 - env$BIO7,
  envRCP$BIO8S - env$BIO8S,
  envRCP$BIO9S - env$BIO9S,
  envRCP$BIO10S - env$BIO10S,
  envRCP$BIO11S - env$BIO11S,
  envRCP$BIO12 - env$BIO12,
  envRCP$BIO13 - env$BIO13,
  envRCP$BIO14 - env$BIO14,
  envRCP$BIO15 - env$BIO15,
  envRCP$BIO16S - env$BIO16S,
  envRCP$BIO17S - env$BIO17S,
  envRCP$BIO18S - env$BIO18S,
  envRCP$BIO19S - env$BIO19S,
  envRCP$slope - env$slope,
  envRCP$alt- env$alt,
  envRCP$lakes - env$lakes,
  envRCP$riv_3km - env$riv_3km,   
  envRCP$samp_20km - env$samp_20km,   
  envRCP$pix_dist - env$pix_dist
)

# Stack the result
diff_stack <- stack(diff_list)

# Name the layers
names(diff_stack) <-c("BIO1","BIO2","BIO3","BIO4","BIO5","BIO6","BIO7","BIO8S","BIO9S","BIO10S","BIO11S","BIO12","BIO13","BIO14","BIO15","BIO16S","BIO17S","BIO18S","BIO19S","slope","alt","lakes","riv_3km","samp_20km","pix_dist")

# Plot in 4s:
plot(diff_stack[[1:4]], col = rev(brewer.pal(9, "YlGnBu")))
plot(diff_stack[[5:8]], col = rev(brewer.pal(9, "YlGnBu")))
plot(diff_stack[[5:8]], col = rev(brewer.pal(9, "YlGnBu")))
plot(diff_stack[[9:12]], col = rev(brewer.pal(9, "YlGnBu")))
plot(diff_stack[[13:16]], col = rev(brewer.pal(9, "YlGnBu")))
plot(diff_stack[[17:19]], col = rev(brewer.pal(9, "YlGnBu")))
plot(diff_stack[[20:25]], col = rev(brewer.pal(9, "YlGnBu")))
```  

## Delta: Forecast - current 

## Unscaled predicted CSE
```{r delta, warning=FALSE}
# Raw CSE raster layers
con_raster_forecast <- rast(file.path(results_dir, "fullRF_CSE_resistance_RCP4_5.tif"))
con_raster <- rast(file.path(results_dir, "fullRF_CSE_resistance.tif"))

# Crop to overlapping extent
con_raster_forecast <- crop(con_raster_forecast, sdm)
con_raster <- crop(con_raster, sdm)

# Compute difference
delta_raster <- con_raster_forecast - con_raster
  
# Mask to common suitable area
delta_raster <- mask(delta_raster,sdm)

# Get true min and max
zrange <- range(values(delta_raster), na.rm = TRUE)
zmin <- zrange[1]
zmax <- zrange[2]

# Choose number of colors
n_colors <- 100

# Split color count proportionally around zero
n_neg <- round(n_colors * abs(zmin) / (abs(zmin) + abs(zmax)))
n_pos <- n_colors - n_neg

# Build color ramps to white (centered at 0)
neg_col <- colorRampPalette(c("#924532", "darkorange", "gold", "white"))(n_neg) #red4
pos_col <- colorRampPalette(c("white", "#8db4c9", "deepskyblue3", "blue4"))(n_pos) #lightgreen

# Combine (removing duplicate white)
custom_diverging <- c(neg_col, pos_col[-1])

#Plot with exact matching zlim:

plot(delta_raster,
     col = custom_diverging,
     main = "Projected Change in Connectivity",
     axes = FALSE, box = FALSE,
     zlim = c(zmin, zmax),
     legend.args = list(text = "Change", side = 1, line = 2.5, cex = 0.8))

plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda), border = "black", lwd = .25, add = TRUE)
```
  
## Scaled inverse CSE
```{r delta-con, warning=FALSE}

# Using scaled inverse CSE
delta_con <- con_forecast - con

# Get true min and max
zrange <- range(values(delta_con), na.rm = TRUE)
zmin <- zrange[1]
zmax <- zrange[2]

# Choose number of colors
n_colors <- 100

# Split color count proportionally around zero
n_neg <- round(n_colors * abs(zmin) / (abs(zmin) + abs(zmax)))
n_pos <- n_colors - n_neg

# Build color ramps to white (centered at 0)
neg_col <- rev(colorRampPalette(c("white", "#8db4c9", "deepskyblue3", "blue4"))(n_neg)) #lightgreen
pos_col <- rev(colorRampPalette(c("#924532", "darkorange", "gold", "white"))(n_pos)) #red4

# Combine (removing duplicate white)
custom_diverging <- c(neg_col, pos_col[-1])

#Plot with exact matching zlim:

plot(delta_con,
     col = custom_diverging,
     main = "Projected Change in Connectivity",
     axes = FALSE, box = FALSE,
     zlim = c(zmin, zmax),
     legend.args = list(text = "Change", side = 1, line = 2.5, cex = 0.8))

plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda), border = "black", lwd = .25, add = TRUE)
```

# 9. Figures for paper  

## lakes and Uganda
```{r background-map, warnings=FALSE}
# Load env stack with named layers
ref_raster <- stack(file.path(data_dir, "processed", "env_stack.grd"))
lakes <- st_read(file.path(data_dir, "raw/ne_10m_lakes.shp"), quiet = TRUE)
lakes <- st_transform(lakes, crs = st_crs(ref_raster))  # match CRS 
lakes <- st_make_valid(lakes) # fix geometries
r_ext <- st_as_sfc(st_bbox(ref_raster)) # extent
st_crs(r_ext) <- st_crs(ref_raster) # match CRS
lakes <- st_intersection(lakes, r_ext) # clip to extent
uganda <- rnaturalearth::ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
uganda <- st_intersection(uganda, r_ext) # clip to extent

# Convert lakes and uganda to sf if needed
if (!inherits(lakes, "sf")) lakes <- st_as_sf(lakes)
if (!inherits(uganda, "sf")) uganda <- st_as_sf(uganda)

# Reproject lakes and uganda to match raster CRS
if (st_crs(lakes) != crs(ref_raster)) lakes <- st_transform(lakes, crs(ref_raster))
if (st_crs(uganda) != crs(ref_raster)) uganda <- st_transform(uganda, crs(ref_raster))

# Convert sf to SpatVector for terra mask() and crop()
lakes_v <- vect(lakes)
uganda_v <- vect(uganda)

```
## con and sdm
```{r con-sdm, warnings=FALSE}
# Load raster layers
con_raster <- rast(file.path(results_dir, "fullRF_CSE_resistance.tif"))
fao <- rast(file.path(data_dir, "FAO_fuscipes_2001.tif"))
update <- rast(file.path(data_dir, "SDM_2018update.tif"))

# Match extent and resolution first
fao_crop <- crop(fao, update)
update_crop <- crop(update, fao_crop)
fao_resamp <- resample(fao_crop, update_crop)  # if needed to match resolution

# Combine
sdm_raw <- max(fao_resamp, update_crop, na.rm = TRUE)

# Crop to overlapping extent
sdm <- crop(sdm_raw, con_raster)
con <- crop(con_raster, sdm)

# Mask low-suitability areas
sdm[sdm <= 0.05] <- NA


# Rescale to 0–1
sdm_min <- global(sdm, "min", na.rm = TRUE)$min
sdm_max <- global(sdm, "max", na.rm = TRUE)$max
sdm <- (sdm - sdm_min) / (sdm_max - sdm_min)

# Mask to common suitable area
con <- mask(con, sdm)

# Rescale inverse of CSE to 0-1
con_min <- global(con, "min", na.rm = TRUE)$min
con_max <- global(con, "max", na.rm = TRUE)$max
con <- 1 - ((con - con_min) / (con_max - con_min))
```

### Colors
Connectivity colors from bivmap
low = #d6ce7c, "DarkKhaki", rgba(206, 200, 146, 1)
high = #924532, "Sienna", rgba(146, 69, 50, 1)

Suitability colors from bivmap
low = #8db4c9, "LightSteelBlue", rgba(141, 180, 201, 1)
high = #55306a, "DarkSlateBlue", rgba(85, 48, 106, 1)

## 9a. Connectivity and Suitability companion maps with custom colors
```{r figures, warning=FALSE}

# Plot with custom colors
# Custom palette #1 based on Bishop et al.
connectivity_colors <- colorRampPalette(c("#c5c3a7","#ffe60c","#c79620", "#934334","#802839", "#6f0f40"))(100) #"#d6ce7c"
suitability_colors  <- colorRampPalette(c("lightgray", "#7fabb9","#3c94c8","#595379","#54306a"))(100)  #"#617189"


# Plot lines of Genetic Connectivity (inverse CSE with custom colors)
lines_sf <- st_read(file.path(data_dir,"processed","LC_paths.shp"), quiet=TRUE)
line_colors <- connectivity_colors
con_vals <- 1 - ((lines_sf$CSE - con_min) / (con_max - con_min))
con_cols <- line_colors[cut(con_vals, breaks = seq(0, 1, length.out = 101), include.lowest = TRUE)]
plot(con, col = connectivity_colors,
     axes = FALSE, box = FALSE,
     zlim = c(0,1),
     legend.args = list(text = "Connectivity", side = 2, line = 2.5, cex = 0.8))
plot(con, col = "white",
     axes = FALSE, box = FALSE, legend = FALSE, add = TRUE)
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(lines_sf), col = con_cols, lwd = 0.6, add = TRUE)
plot(st_geometry(uganda_cropped), border = "black", lwd = 1, add = TRUE)


# Plot Genetic Connectivity (inverse CSE) with custom colors
plot(con,
     col = connectivity_colors,
     #main = "Genetic Connectivity (inverse CSE)",
     axes = FALSE, box = FALSE,
     zlim = c(0,1),
     legend.args = list(text = "Connectivity", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda_cropped), border = "black", lwd = 1, add = TRUE)

# Plot Habitat Suitability with custom colors
plot(sdm,
     col = suitability_colors,
     #main = "Habitat Suitability",
     axes = FALSE, box = FALSE,
     legend.args = list(text = "Suitability", side = 2, line = 2.5, cex = 0.8))
plot(st_geometry(lakes), col = "black", border = NA, add = TRUE)
plot(st_geometry(uganda_cropped), border = "black", lwd = 1, add = TRUE)
```
## 9b. Env change --- Forecasted changes

```{r env-tiles, warning=FALSE}
# Create the difference layers
diff_list <- list(
  envRCP$BIO1 - env$BIO1,
  envRCP$BIO2 - env$BIO2,
  envRCP$BIO3 - env$BIO3,
  envRCP$BIO4 - env$BIO4,
  envRCP$BIO5 - env$BIO5,
  envRCP$BIO6 - env$BIO6,
  envRCP$BIO7 - env$BIO7,
  envRCP$BIO8S - env$BIO8S,
  envRCP$BIO9S - env$BIO9S,
  envRCP$BIO10S - env$BIO10S,
  envRCP$BIO11S - env$BIO11S,
  envRCP$BIO12 - env$BIO12,
  envRCP$BIO13 - env$BIO13,
  envRCP$BIO14 - env$BIO14,
  envRCP$BIO15 - env$BIO15,
  envRCP$BIO16S - env$BIO16S,
  envRCP$BIO17S - env$BIO17S,
  envRCP$BIO18S - env$BIO18S,
  envRCP$BIO19S - env$BIO19S,
  envRCP$slope - env$slope,
  envRCP$alt- env$alt,
  envRCP$lakes - env$lakes,
  envRCP$riv_3km - env$riv_3km,   
  envRCP$samp_20km - env$samp_20km,   
  envRCP$pix_dist - env$pix_dist
)

# Variable names
layer_names <- c(
  "BIO1","BIO2","BIO3","BIO4","BIO5","BIO6","BIO7",
  "BIO8S","BIO9S","BIO10S","BIO11S","BIO12","BIO13","BIO14","BIO15",
  "BIO16S","BIO17S","BIO18S","BIO19S",
  "slope","alt","lakes","riv_3km","samp_20km","pix_dist"
)

# Convert and assign names individually
diff_list <- lapply(seq_along(diff_list), function(i) {
  r <- terra::rast(diff_list[[i]])
  names(r) <- layer_names[i]
  return(r)
})

# Stack into a multi-layer SpatRaster
diff_stack <- do.call(c, diff_list)

# Reference raster for extent, resolution, and CRS
ref_raster <- con

#pdf("Env_change_panels.pdf", width = 7, height = 7) # Optional: save to PDF
#par(mfrow = c(2, 2), mar = c(4, 2, 2, 3))  # More space for legend

for (i in 1:nlyr(diff_stack)) {
  r <- diff_stack[[i]]
  title <- names(r)

  # Crop and mask to reference raster
  r <- crop(r, ref_raster)
  r <- mask(r, ref_raster)  # removes extra NA/edge artifacts

  # Get value range
  zr <- global(r, fun = range, na.rm = TRUE, names = FALSE)
  zmin <- zr[1, 1]
  zmax <- zr[1, 2]

  # Choose number of color bins
  n <- 100

  # Build diverging palette centered on 0
  if (is.na(zmin) || is.na(zmax)) {
    cols <- rep("white", n)
    zlim <- c(0, 0)
  } else if (zmin >= 0) {
    cols <- colorRampPalette(c("white", "gold", "darkorange","#924532" ))(n)
    zlim <- c(0, zmax)
  } else if (zmax <= 0) {
    cols <- colorRampPalette(c("blue4", "deepskyblue3", "#8db4c9", "white"))(n)
    zlim <- c(zmin, 0)
  } else {
    n_neg <- max(1, round(n * abs(zmin) / (abs(zmin) + abs(zmax))))
    n_pos <- max(1, n - n_neg)
    # Swap here: blues for negative, warm colors for positive
    neg_col <- colorRampPalette(c("blue4", "deepskyblue3", "#8db4c9",   "white"))(n_neg)
    pos_col <- colorRampPalette(c("white", "gold", "darkorange",   "#924532"))(n_pos)
    cols <- c(neg_col, pos_col[-1])
    zlim <- c(zmin, zmax)
  }
  # Plot raster
  plot(r,
       col = cols,
       zlim = zlim,
       main = title,
       axes = FALSE, box = FALSE,
       legend.args = list(text = "Change", side = 1, line = 2.5, cex = 0.8))

  # Overlay lakes and uganda outline
  plot(lakes_v, col = "black", border = NA, add = TRUE)
  plot(uganda_v, border = "black", lwd = 0.25, add = TRUE)
}


#dev.off()

```
## 9c. Current raw conditions
```{r plot-raw-env}
# Create the difference layers
env_list <- list(
  env$BIO1 - envRCP$BIO1 + envRCP$BIO1,
  env$BIO2 - envRCP$BIO2 + envRCP$BIO2,
  env$BIO3 - envRCP$BIO3 + envRCP$BIO3,
  env$BIO4 - envRCP$BIO4 + envRCP$BIO4,
  env$BIO5 - envRCP$BIO5 + envRCP$BIO5,
  env$BIO6 - envRCP$BIO6 + envRCP$BIO6,
  env$BIO7 - envRCP$BIO7 + envRCP$BIO7,
  env$BIO8S - envRCP$BIO8S + envRCP$BIO8S,
  env$BIO9S - envRCP$BIO9S + envRCP$BIO9S,
  env$BIO10S - envRCP$BIO10S + envRCP$BIO10S,
  env$BIO11S - envRCP$BIO11S + envRCP$BIO11S,
  env$BIO12 - envRCP$BIO12 + envRCP$BIO12,
  env$BIO13 - envRCP$BIO13 + envRCP$BIO13,
  env$BIO14 - envRCP$BIO14 + envRCP$BIO14,
  env$BIO15 - envRCP$BIO15 + envRCP$BIO15,
  env$BIO16S - envRCP$BIO16S + envRCP$BIO16S,
  env$BIO17S - envRCP$BIO17S + envRCP$BIO17S,
  env$BIO18S - envRCP$BIO18S + envRCP$BIO18S,
  env$BIO19S - envRCP$BIO19S + envRCP$BIO19S,
  env$slope - envRCP$slope + envRCP$slope,
  env$alt - envRCP$alt + envRCP$alt,
  env$lakes - envRCP$lakes + envRCP$lakes,
  env$riv_3km - envRCP$riv_3km + envRCP$riv_3km, 
  env$samp_20km - envRCP$samp_20km + envRCP$samp_20km,      
  env$pix_dist - envRCP$pix_dist + envRCP$pix_dist
)

# Variable names
layer_names <- c(
  "BIO1","BIO2","BIO3","BIO4","BIO5","BIO6","BIO7",
  "BIO8S","BIO9S","BIO10S","BIO11S","BIO12","BIO13","BIO14",
  "BIO15","BIO16S","BIO17S","BIO18S","BIO19S",
  "slope","alt","lakes","riv_3km","samp_20km","pix_dist"
)

# Convert and assign names individually
env_list <- lapply(seq_along(env_list), function(i) {
  r <- terra::rast(env_list[[i]])
  names(r) <- layer_names[i]
  return(r)
})

# Stack into a multi-layer SpatRaster
env_stack <- do.call(c, env_list)

# Reference raster for extent, resolution, and CRS
ref_raster <- con

#pdf("Env_change_panels.pdf", width = 7, height = 7) # Optional: save to PDF
#par(mfrow = c(2, 2), mar = c(4, 2, 2, 3))  # More space for legend

for (i in 1:nlyr(env_stack)) {
  r <- diff_stack[[i]]
  title <- names(r)

  # Crop and mask to reference raster
  r <- crop(r, ref_raster)
  r <- mask(r, ref_raster)  # removes extra NA/edge artifacts

  # Get masked values and compute mean-centered limits
  r_vals <- values(r)
  r_vals <- r_vals[!is.na(r_vals)]

  if (length(r_vals) == 0) {
    cols <- rep("white", 100)
    zlim <- c(0, 0)
  } else {
    r_mean <- mean(r_vals)
    r_range <- range(r_vals)
    zmax <- max(abs(r_range[2] - r_mean), abs(r_range[1] - r_mean))
    zlim <- c(r_mean - zmax, r_mean + zmax)

    # Define diverging palette centered at mean
    n <- 100
    n_half <- floor(n / 2)
    neg_col <- colorRampPalette(c("blue4", "deepskyblue3", "#8db4c9", "white"))(n_half + 1)
    pos_col <- colorRampPalette(c("white", "gold", "darkorange", "#924532"))(n_half + 1)
    cols <- c(neg_col, pos_col[-1])  # remove duplicate white
  }

  # Plot raster
  plot(r,
       col = cols,
       zlim = zlim,
       main = title,
       axes = FALSE, box = FALSE,
       legend.args = list(side = 1, line = 2.5, cex = 0.8))

  # Overlay lakes and uganda outline
  plot(lakes_v, col = "black", border = NA, add = TRUE)
  plot(uganda_v, border = "black", lwd = 0.25, add = TRUE)
}


#dev.off()

```

## 9d. Forecast conditions
```{r plot-forecast-env}
# Create the difference layers
env_list <- list(
  envRCP$BIO1 - env$BIO1 + env$BIO1,
  envRCP$BIO2 - env$BIO2 + env$BIO2,
  envRCP$BIO3 - env$BIO3 + env$BIO3,
  envRCP$BIO4 - env$BIO4 + env$BIO4,
  envRCP$BIO5 - env$BIO5 + env$BIO5,
  envRCP$BIO6 - env$BIO6 + env$BIO6,
  envRCP$BIO7 - env$BIO7 + env$BIO7,
  envRCP$BIO8S - env$BIO8S + env$BIO8S,
  envRCP$BIO9S - env$BIO9S + env$BIO9S,
  envRCP$BIO10S - env$BIO10S + env$BIO10S,
  envRCP$BIO11S - env$BIO11S + env$BIO11S,
  envRCP$BIO12 - env$BIO12 + env$BIO12,
  envRCP$BIO13 - env$BIO13 + env$BIO13,
  envRCP$BIO14 - env$BIO14 + env$BIO14,
  envRCP$BIO15 - env$BIO15 + env$BIO15,
  envRCP$BIO16S - env$BIO16S + env$BIO16S,
  envRCP$BIO17S - env$BIO17S + env$BIO17S,
  envRCP$BIO18S - env$BIO18S + env$BIO18S,
  envRCP$BIO19S - env$BIO19S + env$BIO19S,
  envRCP$slope - env$slope + env$slope,
  envRCP$alt - env$alt + env$alt,
  envRCP$lakes - env$lakes + env$lakes,
  envRCP$riv_3km - env$riv_3km + env$riv_3km, 
  envRCP$samp_20km - env$samp_20km + env$samp_20km,      
  envRCP$pix_dist - env$pix_dist + env$pix_dist
)

# Variable names
layer_names <- c(
  "RCP4.5 BIO1","RCP4.5 BIO2","RCP4.5 BIO3","RCP4.5 BIO4","RCP4.5 BIO5","RCP4.5 BIO6","RCP4.5 BIO7",
  "BIO8S","RCP4.5 BIO9S","RCP4.5 BIO10S","RCP4.5 BIO11S","RCP4.5 BIO12","RCP4.5 BIO13","RCP4.5 BIO14",
  "RCP4.5 BIO15","BIO16S","RCP4.5 BIO17S","RCP4.5 BIO18S","RCP4.5 BIO19S",
  "slope","alt","lakes","riv_3km","samp_20km","pix_dist"
)

# Convert and assign names individually
env_list <- lapply(seq_along(env_list), function(i) {
  r <- terra::rast(env_list[[i]])
  names(r) <- layer_names[i]
  return(r)
})

# Stack into a multi-layer SpatRaster
env_stack <- do.call(c, env_list)

# Reference raster for extent, resolution, and CRS
ref_raster <- con

#pdf("Env_change_panels.pdf", width = 7, height = 7) # Optional: save to PDF
#par(mfrow = c(2, 2), mar = c(4, 2, 2, 3))  # More space for legend

for (i in 1:nlyr(env_stack)) {
  r <- diff_stack[[i]]
  title <- names(r)

  # Crop and mask to reference raster
  r <- crop(r, ref_raster)
  r <- mask(r, ref_raster)  # removes extra NA/edge artifacts

  # Get masked values and compute mean-centered limits
  r_vals <- values(r)
  r_vals <- r_vals[!is.na(r_vals)]

  if (length(r_vals) == 0) {
    cols <- rep("white", 100)
    zlim <- c(0, 0)
  } else {
    r_mean <- mean(r_vals)
    r_range <- range(r_vals)
    zmax <- max(abs(r_range[2] - r_mean), abs(r_range[1] - r_mean))
    zlim <- c(r_mean - zmax, r_mean + zmax)

    # Define diverging palette centered at mean
    n <- 100
    n_half <- floor(n / 2)
    neg_col <- colorRampPalette(c("blue4", "deepskyblue3", "#8db4c9", "white"))(n_half + 1)
    pos_col <- colorRampPalette(c("white", "gold", "darkorange", "#924532"))(n_half + 1)
    cols <- c(neg_col, pos_col[-1])  # remove duplicate white
  }

  # Plot raster
  plot(r,
       col = cols,
       zlim = zlim,
       main = title,
       axes = FALSE, box = FALSE,
       legend.args = list(side = 1, line = 2.5, cex = 0.8))

  # Overlay lakes and uganda outline
  plot(lakes_v, col = "black", border = NA, add = TRUE)
  plot(uganda_v, border = "black", lwd = 0.25, add = TRUE)
}


#dev.off()

```

### I'm thinking now I want to make similar plots that show the Pearson's r in a sliding window, of the current/future/direction-of-change of variable versus full model.

